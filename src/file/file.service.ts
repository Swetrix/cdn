import {
  Injectable,
  UnauthorizedException,
  InternalServerErrorException,
  StreamableFile,
  NotFoundException,
} from '@nestjs/common'
import { extname, join, resolve } from 'path'
import { existsSync, mkdirSync, createReadStream } from 'fs'
import { promises as fs } from 'fs'
import * as crypto from 'crypto'

import { ACCESS_TOKEN, UPLOAD_PATH } from '../common/constants'

@Injectable()
export class FileService {
  /**
   * Perform a timing-safe comparison between the provided token and the configured ACCESS_TOKEN.
   * Using crypto.timingSafeEqual helps to mitigate timing-based side-channel attacks.
   */
  verifyAuth(token: string) {
    if (!token) {
      throw new UnauthorizedException('Missing access token')
    }

    // Convert both tokens to buffers for timing-safe comparison
    const provided = Buffer.from(token)
    const expected = Buffer.from(ACCESS_TOKEN)

    // If the lengths are different we can immediately reject, but keep the comparison
    // path for constant time behaviour.
    const lenMismatch = provided.length !== expected.length
    const providedView = new Uint8Array(
      provided.buffer,
      provided.byteOffset,
      provided.byteLength,
    )
    const expectedView = new Uint8Array(
      expected.buffer,
      expected.byteOffset,
      expected.byteLength,
    )
    const match =
      !lenMismatch && crypto.timingSafeEqual(providedView, expectedView)

    if (!match) {
      // TODO: Add rate limiting
      throw new UnauthorizedException('Invalid access token')
    }
  }

  /**
   * Validate that the provided filename was generated by this service.
   * It must follow the pattern: 32 hexadecimal characters + extension (e.g. jpg, png, js).
   * Additionally, it prevents path traversal attempts by ensuring the resolved path is
   * still located inside the configured UPLOAD_PATH directory.
   */
  private validateFilename(filename: string) {
    const randomPattern = /^[a-f0-9]{32}\.[a-z0-9]+$/i
    const safeCustomPattern = /^[a-zA-Z0-9_.-]{1,100}$/

    if (!(randomPattern.test(filename) || safeCustomPattern.test(filename))) {
      throw new NotFoundException('File not found')
    }

    // Ensure no path traversal â€“ the resolved path must stay within UPLOAD_PATH
    const resolved = resolve(join(UPLOAD_PATH, filename))
    if (!resolved.startsWith(resolve(UPLOAD_PATH))) {
      throw new NotFoundException('File not found')
    }

    return resolved
  }

  async getFile(filename: string) {
    const path = `${UPLOAD_PATH}/${filename}`

    if (!existsSync(path)) {
      throw new NotFoundException('File not found')
    }

    try {
      const file = createReadStream(path)
      return new StreamableFile(file)
    } catch (reason) {
      console.error(
        `[ERROR]: An error happened while reading the file (${UPLOAD_PATH}/${filename}): ${reason}`,
      )
      throw new InternalServerErrorException(
        'An error happened while reading the file',
      )
    }
  }

  async saveFile(file: Express.Multer.File) {
    const id = crypto.randomBytes(16).toString('hex')
    const filename = `${id}${extname(file.originalname)}`
    const path = `${UPLOAD_PATH}/${filename}`

    if (!existsSync(UPLOAD_PATH)) {
      mkdirSync(UPLOAD_PATH)
    }

    try {
      await fs.writeFile(path, new Uint8Array(file.buffer))
    } catch {
      throw new InternalServerErrorException(
        'An error happened while saving the file',
      )
    }

    return {
      filename,
    }
  }

  async saveMultipleFiles(files: Express.Multer.File[]) {
    const filenames = []

    for (const file of files) {
      const id = crypto.randomBytes(16).toString('hex')
      const filename = `${id}${extname(file.originalname)}`
      const path = `${UPLOAD_PATH}/${filename}`

      filenames.push(filename)

      if (!existsSync(UPLOAD_PATH)) {
        mkdirSync(UPLOAD_PATH)
      }

      try {
        await fs.writeFile(path, new Uint8Array(file.buffer))
      } catch {
        throw new InternalServerErrorException(
          'An error happened while saving the file',
        )
      }
    }

    return {
      filenames,
    }
  }

  async deleteFile(filename: string) {
    const path = this.validateFilename(filename)

    try {
      await fs.unlink(path)
    } catch (reason) {
      if (reason.code === 'ENOENT') {
        throw new NotFoundException('File not found')
      }

      console.error(
        `[ERROR]: An error happened while removing the file (${UPLOAD_PATH}/${filename}): ${reason}`,
      )

      throw new InternalServerErrorException(
        'An error happened while removing the file',
      )
    }
  }
}
